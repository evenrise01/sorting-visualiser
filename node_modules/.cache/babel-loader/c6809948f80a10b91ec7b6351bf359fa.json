{"ast":null,"code":"function swap(arr, val1, val2) {\n  let temp = arr[val2];\n  arr[val2] = arr[val1];\n  arr[val1] = temp;\n}\n\nexport function getHeapSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  let size = array.length;\n  doHeapSort(array, size, animations);\n  return animations;\n} //Recursive heapify function. We call until we find the root of the array\n\nfunction heapify(array, size, i, animations) {\n  let root = i;\n  let left = 2 * i + 1;\n  let right = 2 * i + 2;\n\n  if (left < size && array[left] > array[root]) {\n    animations.push([root, left, false]);\n    animations.push([root, left, false]);\n    root = left;\n  }\n\n  if (right < size && array[right] > array[root]) {\n    animations.push([root, right, false]);\n    animations.push([root, right, false]);\n    root = right;\n  } //Root has changed because i was not the root\n\n\n  if (root != i) {\n    animations.push([root, array[i], true]);\n    animations.push([i, array[root], true]); //If root is not i, then swap the values, call heapify recursively\n\n    swap(array, root, i);\n    heapify(array, size, root, animations);\n  }\n}\n\nfunction doHeapSort(array, size, animations) {\n  // Create max heap\n  for (let i = size / 2 - 1; i >= 0; i--) {\n    heapify(array, size, i, animations);\n  } // Now do the actual heap sort\n\n\n  for (let i = size - 1; i >= 0; i--) {\n    animations.push([i, array[0], true]);\n    animations.push([0, array[i], true]);\n    swap(array, i, 0);\n    heapify(array, i, 0, animations);\n  }\n}","map":{"version":3,"sources":["D:/Study/ITS Project/Sorting-Visualizer/src/sortingAlgorithms/HeapSort.js"],"names":["swap","arr","val1","val2","temp","getHeapSortAnimations","array","animations","length","size","doHeapSort","heapify","i","root","left","right","push"],"mappings":"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","sourcesContent":["function swap(arr, val1, val2) {\r\n    let temp = arr[val2];\r\n    arr[val2] = arr[val1];\r\n    arr[val1] = temp;\r\n}\r\n\r\nexport function getHeapSortAnimations(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n    let size = array.length;\r\n    doHeapSort(array, size, animations);\r\n    return animations;\r\n}\r\n//Recursive heapify function. We call until we find the root of the array\r\nfunction heapify(array, size, i, animations) {\r\n    let root = i;\r\n    let left = 2 * i + 1;\r\n    let right = 2 * i + 2;\r\n    if (left < size && array[left] > array[root]) {\r\n        animations.push([root, left, false]);\r\n        animations.push([root, left, false]);\r\n        root = left;\r\n    }\r\n    if (right < size && array[right] > array[root]) {\r\n        animations.push([root, right, false]);\r\n        animations.push([root, right, false]);\r\n        root = right;\r\n    }\r\n    //Root has changed because i was not the root\r\n    if (root != i) {\r\n        animations.push([root, array[i], true]);\r\n        animations.push([i, array[root], true]);\r\n        //If root is not i, then swap the values, call heapify recursively\r\n        swap(array, root, i);\r\n        heapify(array, size, root, animations);\r\n    }\r\n}\r\nfunction doHeapSort(array, size, animations) {\r\n    // Create max heap\r\n    for (let i = (size / 2) - 1; i >= 0; i--) {\r\n        heapify(array, size, i, animations);\r\n    }\r\n    // Now do the actual heap sort\r\n    for (let i = size - 1; i >= 0; i--) {\r\n        animations.push([i, array[0], true]);\r\n        animations.push([0, array[i], true]);\r\n        swap(array, i, 0);\r\n        heapify(array, i, 0, animations);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}